let race = 30; //длина трассы
let prevPosition = null; //для сохранения значения текущей позиции 1-ой машинки
let prevPosition2 = null; //то же для второй машинки
let track = new Array(30).fill("|"); // создание трассы
let track2 = new Array(30).fill("|"); // создание второй трассы

function moveCar1(position) {
  // moveCar2(0)
  for (i = 0; i <= race; i = position) {
    // // // // Костылявохитровыделанное решение выполнять итерацию с паузой чуть больше секунды===============
    // function fiboRecurs(n) {
    //   if (n <= 1) {
    //     return n;
    //   }
    //   {
    //     return fiboRecurs(n - 1) + fiboRecurs(n - 2);
    //   }
    // }
    // fiboRecurs(40);
//==========================================================================================================
    console.clear(); //очищаем экран от предыдущего вывода, это работает только в терминале
    console.log(position); //вывод индекса текущего положения на каждом этапе броска кубика
    track.splice(position, 1, "car"); //рисуем машинку на нужной позиции
    console.log(track.join("  ")); //соединяем массив в строку для визуальности вывода, для красоты вобщем.
    prevPosition = position; // 'запоминаем текущее положение/индекс машинки, т.к. на следующем шаге оно изменится
    position = Math.floor(Math.random() * 6) + 1 + position; //складываем к текущему положению значение кубика и положение менятся

    if (position > 30) {
      console.log("ВЫ достигли финиша");
    } //если позиция после броска будет больше 30 - значит победа.
    track.splice(prevPosition, 1, "|"); //удаляем 'рисунок' машинки на предыдущей позиции
  }

  return position;
}

//всё что выше, тоже самое и для второй машинки
function moveCar2(position2) {
  for (i = 0; i <= race; i = position2) {
    // // // Костылявохитровыделанное решение выполнять итерацию с паузой чуть больше секунды===============
    function fiboRecurs(n) {
      if (n <= 1) {
        return n;
      }
      {
        return fiboRecurs(n - 1) + fiboRecurs(n - 2);
      }
    }
    fiboRecurs(40);
//==========================================================================================================
    console.clear(); //очищаем экран от предыдущего вывода, это работает только в терминале
    console.log(position2); //вывод индекса текущего положения на каждом этапе броска кубика
    track.splice(position2, 1, "car"); //рисуем машинку на нужной позиции
    console.log(track.join("  ")); //соединяем массив в строку для визуальности вывода, для красоты вобщем.
    prevPosition2 = position2; // 'запоминаем текущее положение/индекс машинки, т.к. на следующем шаге оно изменится
    position2 = Math.floor(Math.random() * 6) + 1 + position2; //складываем к текущему положению значение кубика и положение менятся

    if (position2 > 30) {
      console.log("ВЫ достигли финиша");
    } //если позиция после броска будет больше 30 - значит победа.
    track.splice(prevPosition2, 1, "|"); //удаляем 'рисунок' машинки на предыдущей позиции
  }

  return position2;
}

//ТЕСТ//
moveCar1(0)

//===================другой вариант==================


    // moveCar2(0)
    // ( i <= race; i = position)
    let race = 30; //длина трассы
let prevPosition = 0; //для сохранения значения текущей позиции 1-ой машинки
let prevPosition2 = 0; //то же для второй машинки
let track = new Array(30).fill("|"); // создание трассы
let track2 = new Array(30).fill("|"); // создание второй трассы
let position = 0
let position2 = 0
   
    
    
      // // // // Костылявохитровыделанное решение выполнять итерацию с паузой чуть больше секунды===============
      // function fiboRecurs(n) {
      //   if (n <= 1) {
      //     return n;
      //   }
      //   {
      //     return fiboRecurs(n - 1) + fiboRecurs(n - 2);
      //   }
      // }
      // fiboRecurs(40);
  //==========================================================================================================
      // console.clear(); //очищаем экран от предыдущего вывода, это работает только в терминале
     console.log(position); //вывод индекса текущего положения на каждом этапе броска кубика
      track.splice(position, 1, "car"); //рисуем машинку на нужной позиции
      console.log(track.join("  ")); //соединяем массив в строку для визуальности вывода, для красоты вобщем.
      prevPosition = position; // 'запоминаем текущее положение/индекс машинки, т.к. на следующем шаге оно изменится
      position = Math.floor(Math.random() * 6) + 1 + position; //складываем к текущему положению значение кубика и положение менятся
  
      // if (position > 30) {
        // console.log("ВЫ достигли финиша");
       //если позиция после броска будет больше 30 - значит победа.
      track.splice(prevPosition, 1, "|"); //удаляем 'рисунок' машинки на предыдущей позиции

      //вторая машинка
      console.log(position2); //вывод индекса текущего положения на каждом этапе броска кубика
      track2.splice(position2, 1, "car2"); //рисуем машинку на нужной позиции
      console.log(track2.join("  ")); //соединяем массив в строку для визуальности вывода, для красоты вобщем.
      prevPosition2 = position2; // 'запоминаем текущее положение/индекс машинки, т.к. на следующем шаге оно изменится
      position2 = Math.floor(Math.random() * 6) + 1 + position2; //складываем к текущему положению значение кубика и положение менятся
  
      // if (position > 30) {
        // console.log("ВЫ достигли финиша");
       //если позиция после броска будет больше 30 - значит победа.
      track.splice(prevPosition2, 1, "|"); //удаляем 'рисунок' машинки на предыдущей позиции
    
  
  }


  
